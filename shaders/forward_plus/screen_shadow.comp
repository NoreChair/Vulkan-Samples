#version 320 es
precision highp float;
#extension  GL_NV_compute_shader_derivatives : enable

layout(set = 0, binding = 0) uniform Uniforms{
    vec4 renderExtent;
    vec4 shadowExtent;
    // vec4 cameraPosition;
    // vec4 cameraCorner; // left bottom
    // vec4 cameraProjectPlane[2]; // h v
    mat4 invMainVP;
    mat4 shadowVP;
};

layout(set = 0, binding = 1) uniform sampler2D sceneDepth;
layout(set = 0, binding = 2) uniform highp sampler2DShadow shadowMap;
layout(set = 0, binding = 3) writeonly uniform highp image2D screenShadow;

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

float RegularGridSample(vec3 shadowPos, vec2 rcpShadowExtent){
    // regular grid 3 x 3 sampling
    vec2 kernel[9] = vec2[9](
        rcpShadowExtent * vec2(-1.0), rcpShadowExtent * vec2(0.0, -1.0), rcpShadowExtent * vec2(1.0, -1.0),
        rcpShadowExtent * vec2(-1.0, 0.0), rcpShadowExtent * vec2(0.0), rcpShadowExtent * vec2(1.0, 0.0),
        rcpShadowExtent * vec2(-1.0, 1.0), rcpShadowExtent * vec2(0.0, 1.0), rcpShadowExtent * vec2(1.0)
    );

    float shadowValue = 0.0;
    float shadowCompareZ = shadowPos.z;

    for(uint i = 0u; i < 9u; ++i){
        // for large kernel, is better to use
        // (delta u, delta v) = (delta x) * (ddx u, ddx v) + (delta y) * (ddy u, ddy v);
        // (delta z) = (delta x) * (ddx z) + (delta y) * (ddy z);
        // dest ref z = origin ref z + delta z;
        // to determine shadow pcfs
        vec2 shadowUV = shadowPos.xy + kernel[i];
    #ifdef GL_NV_compute_shader_derivatives
        vec2 dx = dFdx(shadowPos.xy);
        vec2 dy = dFdy(shadowPos.xy);
        mat2 correctMatrix = mat2(dy.y, -dx.y, -dy.x, dx.x) * (1.0 / (dx.x * dy.y - dx.y * dy.x));
        vec2 correctOffset = correctMatrix * kernel[i];
        vec2 dZ = vec2(dFdx(shadowCompareZ), dFdy(shadowCompareZ));
        shadowCompareZ = shadowCompareZ + dot(correctOffset, dZ);
    #endif
        shadowValue += textureLod(shadowMap, vec3(shadowUV, shadowCompareZ), 0.0);
    }

    return shadowValue * 0.1111111111;
}

float PercentageCloserFiltering(vec3 shadowPos){
    float pcf = 0.0;
    const float kernelWidth = 1.0f;
    // TODO : poisson disk sampling
    pcf = RegularGridSample(shadowPos, shadowExtent.zw * kernelWidth);
    return pcf;
}

void main(){
    uvec2 threadIndex = gl_GlobalInvocationID.xy;

    threadIndex = min(threadIndex, uvec2(renderExtent.xy));

    vec2 uv = vec2(threadIndex) * renderExtent.zw;
    float depth = textureLod(sceneDepth, uv, 0.0).r;
    vec4 clipSpace = vec4(uv * vec2(2.0) - vec2(1.0), depth, 1.0);
    vec4 viewSpace = invMainVP * clipSpace;
    vec3 worldPos = viewSpace.xyz / viewSpace.w;

    vec4 positionSS = shadowVP * vec4(worldPos, 1.0);
    positionSS /= positionSS.w;
    positionSS.xy = positionSS.xy * vec2(0.5) + vec2(0.5);

    bvec4 outOfShadow = bvec4(positionSS.x < 0.0, positionSS.x > 1.0, positionSS.y < 0.0, positionSS.y > 1.0);

    float shadowFactor = PercentageCloserFiltering(positionSS.xyz);
    // float shadowFactor = textureLod(shadowMap, positionSS.xyz, 0.0);
    if(any(outOfShadow)){
        imageStore(screenShadow, ivec2(threadIndex), vec4(1.0));
    }else{
        imageStore(screenShadow, ivec2(threadIndex), vec4(shadowFactor));
    }
}
