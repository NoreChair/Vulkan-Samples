#version 320 es
precision highp float;

layout(set = 0, binding = 0) uniform Uniforms{
    vec4 renderExtent;
    vec4 shadowExtent;
    // vec4 cameraPosition;
    // vec4 cameraCorner; // left bottom
    // vec4 cameraProjectPlane[2]; // h v
    mat4 invMainVP;
    mat4 shadowVP;
};

layout(set = 0, binding = 1) uniform sampler2D sceneDepth;
layout(set = 0, binding = 2) uniform highp sampler2DShadow shadowMap;
layout(set = 0, binding = 3) writeonly uniform highp image2D screenShadow;

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

float RegularGridSample(vec3 shadowPos, vec2 rcpShadowExtent){
    // regular grid 3 x 3 sampling
    vec2 kernel[9] = vec2[9](
        rcpShadowExtent * vec2(-1.0), rcpShadowExtent * vec2(0.0, -1.0), rcpShadowExtent * vec2(1.0, -1.0),
        rcpShadowExtent * vec2(-1.0, 0.0), rcpShadowExtent * vec2(0.0), rcpShadowExtent * vec2(1.0, 0.0),
        rcpShadowExtent * vec2(-1.0, 1.0), rcpShadowExtent * vec2(0.0, 1.0), rcpShadowExtent * vec2(1.0)
    );

    float shadowValue = 0.0;
    for(uint i = 0u; i < 9u; ++i){
        // for large kernel, is better to use
        // (delta u, delta v) = (delta x) * (ddx u, ddx v) + (delta y) * (ddy u, ddy v);
        // (delta z) = (delta x) * (ddx z) + (delta y) * (ddy z);
        // dest ref z = origin ref z + delta z;
        // to determine shadow pcf 
        shadowValue += textureLod(shadowMap, vec3(kernel[i] + shadowPos.xy, shadowPos.z), 0.0);
    }

    return shadowValue * 0.1111111111;
}

float PercentageCloserFiltering(vec3 shadowPos){
    float pcf = 0.0;
    const float kernelWidth = 1.0f;
    // TODO : poisson disk sampling
    pcf = RegularGridSample(shadowPos, shadowExtent.zw * kernelWidth);
    return pcf;
}

void main(){
    uvec2 threadIndex = gl_GlobalInvocationID.xy;

    threadIndex = min(threadIndex, uvec2(renderExtent.xy));

    vec2 uv = vec2(threadIndex) * renderExtent.zw;
    float depth = textureLod(sceneDepth, uv, 0.0).r;
    vec4 clipSpace = vec4(uv * vec2(2.0) - vec2(1.0), depth, 1.0);
    vec4 viewSpace = invMainVP * clipSpace;
    vec3 worldPos = viewSpace.xyz / viewSpace.w;

    vec4 positionSS = shadowVP * vec4(worldPos, 1.0);
    positionSS /= positionSS.w;
    positionSS.xy = positionSS.xy * vec2(0.5) + vec2(0.5);

    bvec4 outOfShadow = bvec4(positionSS.x < 0.0, positionSS.x > 1.0, positionSS.y < 0.0, positionSS.y > 1.0);
    float shadowFactor = PercentageCloserFiltering(positionSS.xyz);
    // float shadowFactor = textureLod(shadowMap, positionSS.xyz, 0.0);
    if(any(outOfShadow)){
        imageStore(screenShadow, ivec2(threadIndex), vec4(1.0));
    }else{
        imageStore(screenShadow, ivec2(threadIndex), vec4(shadowFactor));
    }
}
