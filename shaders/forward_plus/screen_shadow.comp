#version 320 es
precision highp float;
#extension  GL_NV_compute_shader_derivatives : enable

#ifdef GL_NV_compute_shader_derivatives
    #define PLANE_BIAS
#endif

layout(set = 0, binding = 0) uniform Uniforms{
    vec4 renderExtent;
    vec4 shadowExtent;
    // vec4 cameraPosition;
    // vec4 cameraCorner; // left bottom
    // vec4 cameraProjectPlane[2]; // h v
    mat4 invMainVP;
    mat4 shadowVP;
};

layout(set = 0, binding = 1) uniform sampler2D sceneDepth;
layout(set = 0, binding = 2) uniform highp sampler2DShadow shadowMap;
layout(set = 0, binding = 3) writeonly uniform highp image2D screenShadow;

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

#ifdef PLANE_BIAS
vec2 plane_shadow_bias(vec3 shadowPos){
    // for large kernel, is better to use
    // (delta u, delta v) = (delta x) * (ddx u, ddx v) + (delta y) * (ddy u, ddy v);
    // (delta z) = (delta x) * (ddx z) + (delta y) * (ddy z);
    // dest ref z = origin ref z + delta z;
    // to determine shadow pcfs
    vec2 dx = dFdx(shadowPos.xy);
    vec2 dy = dFdy(shadowPos.xy);
    mat2 correctMatrix = mat2(dy.y, -dy.x, -dx.y, dx.x) * (1.0 / (dx.x * dy.y - dx.y * dy.x));
    vec2 dZ = vec2(dFdx(shadowPos.z), dFdy(shadowPos.z));
    vec2 correctOffset = correctMatrix * dZ;
    return correctOffset;
}
#endif

float OptimiazedSample(vec3 shadowPos, vec2 rcpShadowExtent){
    vec2 uv = shadowPos.xy * shadowExtent.xy;
    vec2 baseUV = floor(uv + 0.5);

    vec2 st = (uv + 0.5 - baseUV);
    baseUV -= vec2(0.5);
    baseUV *= rcpShadowExtent;

    float shadowValue = 0.0;
    vec2 uvw0 = vec2(-2.0) * st + vec2(3.0);
    vec2 uvw1 = vec2(1.0) + vec2(2.0) * st;
    vec2 uv0 = (vec2(2.0) - st) / uvw0 - vec2(1.0);
    vec2 uv1 = st / uvw1 + vec2(1.0);

#ifdef PLANE_BIAS
    vec2 shadowDepthBais = plane_shadow_bias(shadowPos) * rcpShadowExtent;
    shadowValue += uvw0.x * uvw0.y * textureLod(shadowMap, vec3(baseUV + uv0 * rcpShadowExtent, shadowPos.z + dot(uv0 * rcpShadowExtent, shadowDepthBais)), 0.0);
    shadowValue += uvw1.x * uvw0.y * textureLod(shadowMap, vec3(baseUV + vec2(uv1.x, uv0.y) * rcpShadowExtent, shadowPos.z + dot(vec2(uv1.x, uv0.y) * rcpShadowExtent, shadowDepthBais)), 0.0);
    shadowValue += uvw0.x * uvw1.y * textureLod(shadowMap, vec3(baseUV + vec2(uv0.x, uv1.y) * rcpShadowExtent, shadowPos.z + dot(vec2(uv0.x, uv1.y) * rcpShadowExtent, shadowDepthBais)), 0.0);
    shadowValue += uvw1.x * uvw1.y * textureLod(shadowMap, vec3(baseUV + uv1 * rcpShadowExtent, shadowPos.z + dot(uv1 * rcpShadowExtent, shadowDepthBais)), 0.0);
#else
    shadowValue += uvw0.x * uvw0.y * textureLod(shadowMap, vec3(baseUV + uv0 * rcpShadowExtent, shadowPos.z), 0.0);
    shadowValue += uvw1.x * uvw0.y * textureLod(shadowMap, vec3(baseUV + vec2(uv1.x, uv0.y) * rcpShadowExtent, shadowPos.z), 0.0);
    shadowValue += uvw0.x * uvw1.y * textureLod(shadowMap, vec3(baseUV + vec2(uv0.x, uv1.y) * rcpShadowExtent, shadowPos.z), 0.0);
    shadowValue += uvw1.x * uvw1.y * textureLod(shadowMap, vec3(baseUV + uv1 * rcpShadowExtent, shadowPos.z), 0.0);
#endif
    return shadowValue / 16.0;
}

float PercentageCloserFiltering(vec3 shadowPos){
    float pcf = 0.0;
    const float kernelWidth = 1.0f;
    pcf = OptimiazedSample(shadowPos, shadowExtent.zw * kernelWidth);
    return pcf;
}

void main(){
    uvec2 threadIndex = gl_GlobalInvocationID.xy;

    threadIndex = min(threadIndex, uvec2(renderExtent.xy));

    vec2 uv = vec2(threadIndex) * renderExtent.zw;
    float depth = textureLod(sceneDepth, uv, 0.0).r;
    vec4 clipSpace = vec4(uv * vec2(2.0) - vec2(1.0), depth, 1.0);
    vec4 viewSpace = invMainVP * clipSpace;
    vec3 worldPos = viewSpace.xyz / viewSpace.w;

    vec4 positionSS = shadowVP * vec4(worldPos, 1.0);
    positionSS /= positionSS.w;
    positionSS.xy = positionSS.xy * vec2(0.5) + vec2(0.5);

    bvec4 outOfShadow = bvec4(positionSS.x < 0.0, positionSS.x > 1.0, positionSS.y < 0.0, positionSS.y > 1.0);

    float shadowFactor = PercentageCloserFiltering(positionSS.xyz);
    // float shadowFactor = textureLod(shadowMap, positionSS.xyz, 0.0);
    if(any(outOfShadow)){
        imageStore(screenShadow, ivec2(threadIndex), vec4(1.0));
    }else{
        imageStore(screenShadow, ivec2(threadIndex), vec4(shadowFactor));
    }
}
