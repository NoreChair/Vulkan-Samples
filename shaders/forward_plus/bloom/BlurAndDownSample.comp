#version 450 core
precision highp float;

#define GROUP_THREAD_NUM 8
#define BLUR_RADIUS 4
#define CACHE_COLOR_SIZE 16
#define BLUR_WEIGHT_COUNT 9

layout(set = 0, binding = 0) uniform Uniforms
{
	vec4 sourceExtents;
	vec4 targetExtents;
};

layout(set = 0, binding = 1) uniform sampler2D source;
layout(set = 0, rgba16f, binding = 2) writeonly uniform image2D target;

layout(local_size_x = GROUP_THREAD_NUM, local_size_y = GROUP_THREAD_NUM, local_size_z = 1) in;

shared vec3 ldsColor[CACHE_COLOR_SIZE * CACHE_COLOR_SIZE];
shared vec3 blurredColor[GROUP_THREAD_NUM * GROUP_THREAD_NUM];

void CacheColorToLDS(const uvec2 startID, const uvec2 groupThreadID)
{
	uvec2 mulTowID = groupThreadID * 2;
	vec2  sampleUV = (vec2(startID + mulTowID - BLUR_RADIUS) + 0.5) * sourceExtents.zw;

	vec4 r4 = textureGather(source, sampleUV, 0);
	vec4 g4 = textureGather(source, sampleUV, 1);
	vec4 b4 = textureGather(source, sampleUV, 2);

	uint topLeftIdx = mulTowID.y * CACHE_COLOR_SIZE + mulTowID.x;

	ldsColor[topLeftIdx]                        = vec3(r4.w, g4.w, b4.w);
	ldsColor[topLeftIdx + 1]                    = vec3(r4.z, g4.z, b4.z);
	ldsColor[topLeftIdx + CACHE_COLOR_SIZE]     = vec3(r4.x, g4.x, b4.x);
	ldsColor[topLeftIdx + 1 + CACHE_COLOR_SIZE] = vec3(r4.y, g4.y, b4.y);

	memoryBarrierShared();
	barrier();
}

void main()
{
	const float gaussianWeight[BLUR_WEIGHT_COUNT] = {0.0027, 0.0474, 0.1166, 0.2001, 0.2664, 0.2001, 0.1166, 0.0474, 0.0027};

	const uvec2 groupThreadID    = gl_LocalInvocationID.xy;
	const uvec2 threadStartID    = gl_WorkGroupID.xy * GROUP_THREAD_NUM;
	CacheColorToLDS(threadStartID, groupThreadID);

	// blur color
	const int step  = BLUR_RADIUS;
	vec3      color = vec3(0.0, 0.0, 0.0);

	// horizontal
	uint cacheIndex = (groupThreadID.y + BLUR_RADIUS) * CACHE_COLOR_SIZE + groupThreadID.x + BLUR_RADIUS;
	for (int i = -step; i <= step; ++i)
	{
		color += ldsColor[cacheIndex + i] * gaussianWeight[i + BLUR_RADIUS];
	}

	blurredColor[gl_LocalInvocationIndex] = color;
	memoryBarrierShared();
	barrier();

	ldsColor[cacheIndex] = blurredColor[gl_LocalInvocationIndex];
	memoryBarrierShared();
	barrier();

	// vertical
	color = vec3(0.0, 0.0, 0.0);
	for (int i = -step; i <= step; ++i)
	{
		color += ldsColor[cacheIndex + i * CACHE_COLOR_SIZE] * gaussianWeight[i + BLUR_RADIUS];
	}

	blurredColor[gl_LocalInvocationIndex] = color;
	memoryBarrierShared();
	barrier();

	if (gl_LocalInvocationIndex < 16)
	{
		const uvec2 st           = uvec2((gl_LocalInvocationIndex % 4), (gl_LocalInvocationIndex / 4));
		const uint  cacheStartID = st.y * 2 * GROUP_THREAD_NUM + st.x * 2;

		vec3 result = blurredColor[cacheStartID] + blurredColor[cacheStartID + 1] + blurredColor[cacheStartID + GROUP_THREAD_NUM] + blurredColor[cacheStartID + GROUP_THREAD_NUM + 1];
		result *= 0.25;
		imageStore(target, ivec2(threadStartID / 2 + st), vec4(result, 1.0));
	}
}