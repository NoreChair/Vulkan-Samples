#version 450 core
precision highp float;

layout(set = 0, binding = 0) uniform Uniforms{
    vec4 extent;
    float targetLuma;
	float bloomScale;
    float adaptationRate;
    float minExposure;
    float maxExposure;
    uint pixelCount;
};

layout(set = 0, std430, binding = 1) readonly buffer ExposureBuffer{
    // from 0 to the end
    // exposure, 1.0/exposure, exposure, averageLuma, MinLog, MaxLog, range, rcpRange
    float exposureBuffer[];
};

layout(set = 0, rgba16f, binding = 2) readonly uniform image2D sceneColor;
layout(set = 0, rgba8, binding = 3) writeonly uniform image2D displayImage;
layout(set = 0, binding = 4) uniform sampler2D bloomResult;

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// The Reinhard tone operator.  Typically, the value of k is 1.0, but you can adjust exposure by 1/k.
// I.e. TM_Reinhard(x, 0.5) == TM_Reinhard(x * 2.0, 1.0)

vec3 TM_Reinhard(vec3 hdr, float k /*= 1.0*/)
{
    return hdr / (hdr + k);
}

// The inverse of Reinhard
vec3 ITM_Reinhard(vec3 sdr, float k /*= 1.0*/)
{
    return k * sdr / (k - sdr);
}

vec3 ToneMapACES(vec3 hdr)
{
    const float A = 2.51, B = 0.03, C = 2.43, D = 0.59, E = 0.14;
    return clamp((hdr * (A * hdr + B)) / (hdr * (C * hdr + D) + E), vec3(0.0), vec3(1.0));
}

vec3 InverseToneMapACES(vec3 sdr)
{
    const float A = 2.51, B = 0.03, C = 2.43, D = 0.59, E = 0.14;
    return 0.5 * (D * sdr - sqrt(((D*D - 4.0*C*E) * sdr + 4.0*A*E-2.0*B*D) * sdr + B*B) - B) / (A - C * sdr);
}

// This is the new tone operator.  It resembles ACES in many ways, but it is simpler to evaluate with ALU.  One
// advantage it has over Reinhard-Squared is that the shoulder goes to white more quickly and gives more overall
// brightness and contrast to the image.
// https://www.desmos.com/calculator/sqjhtq4rot
vec3 ToneMapping_Standard(vec3 hdr){
    return TM_Reinhard(hdr * sqrt(hdr), sqrt(4.0 / 27.0));
}

float RGBToLuminance(vec3 rgb){
    return dot(rgb, vec3(0.212671, 0.715160, 0.072169));
}

vec4 Cubic(float v)
{
	const vec4  n = vec4(1.0, 2.0, 3.0, 4.0) - v;
	const vec4  s = n * n * n;
	const float x = s.x;
	const float y = s.y - 4.0 * s.x;
	const float z = s.z - 4.0 * s.y + 6.0 * s.x;
	const float w = 6.0 - x - y - z;
	return vec4(x, y, z, w) * (1.0 / 6.0);
}

vec4 BicubicSampling4(vec2 st)
{
	vec2 texCoords = st;
	vec2 fxy       = fract(texCoords);
	texCoords -= fxy;

	vec4 xcubic = Cubic(fxy.x);
	vec4 ycubic = Cubic(fxy.y);

	vec4 c = texCoords.xxyy + vec2(-0.5, 1.5).xyxy;

	vec4 s      = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);
	vec4 offset = c + vec4(xcubic.yw, ycubic.yw) / s;

	offset *= extent.zzww * 16.0;

	vec4 sample0 = texture(bloomResult, offset.xz);
	vec4 sample1 = texture(bloomResult, offset.yz);
	vec4 sample2 = texture(bloomResult, offset.xw);
	vec4 sample3 = texture(bloomResult, offset.yw);

	float sx = s.x / (s.x + s.y);
	float sy = s.z / (s.z + s.w);

	return mix(mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);
}

void main(){
	ivec2 dispatchID = ivec2(min(gl_GlobalInvocationID.xy, uvec2(extent.xy)));
	vec3 hdrColor = imageLoad(sceneColor, dispatchID).rgb;

    // vec2 uv = vec2(dispatchID) * extent.zw;
    // vec3 bloom = textureLod(bloomResult, uv, 0.0).rgb;
	vec3 bloom = BicubicSampling4(vec2(dispatchID) * 0.0625).rgb;

	// hdrColor += bloom;
    hdrColor *= exposureBuffer[0];
	hdrColor += bloom * bloomScale;
    // TODO : hdr display output

    // hdr scene refers to display refers
	vec3 sdrColor = ToneMapping_Standard(hdrColor);
	imageStore(displayImage, dispatchID, vec4(sdrColor, 1.0));
}