#version 450 core
precision highp float;

#define kLdsPitch 18
#define klocalSharedRows 10

layout(set = 0, binding = 0) uniform Uniforms{
    vec4 extent;
};

layout(set = 0, binding = 1) highp uniform sampler2D depthMap;
layout(set = 0, binding = 1) highp uniform sampler2D colorMap;

shared float localSharedDepth[kLdsPitch * klocalSharedRows];
shared float localSharedR[kLdsPitch * klocalSharedRows];
shared float localSharedG[kLdsPitch * klocalSharedRows];
shared float localSharedB[kLdsPitch * klocalSharedRows];

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

float f16tof32(uint val)
{
    uint sign = (val & 0x8000u) << 16;
    int exponent = int((val & 0x7C00u) >> 10);
    uint mantissa = val & 0x03FFu;
    float f32 = 0.0;
    if(exponent == 0)
    {
        if (mantissa != 0u)
        {
            const float scale = 1.0 / (1 << 24);
            f32 = scale * mantissa;
        }
    }
    else if (exponent == 31)
    {
        return uintBitsToFloat(sign | 0x7F800000u | mantissa);
    }
    else
    {
        exponent -= 15;
        float scale;
        if(exponent < 0)
        {
            // The negative unary operator is buggy on OSX.
            // Work around this by using abs instead.
            scale = 1.0 / (1 << abs(exponent));
        }
        else
        {
            scale = 1 << exponent;
        }
        float decimal = 1.0 + float(mantissa) / float(1 << 10);
        f32 = scale * decimal;
    }

    if (sign != 0u)
    {
        f32 = -f32;
    }

    return f32;
}

float UnpackXY(uint x)
{
    return f16tof32((x & 0x1FF) << 4 | (x >> 9) << 15) * 32768.0;
}

float UnpackZ( uint x )
{
    return f16tof32((x & 0x7FF) << 2 | (x >> 11) << 15) * 128.0;
}

vec3 UnPackVelocity(uint pack){
    return vec3(UnpackXY(pack & 0x3FF), UnpackXY((pack >> 10) & 0x3FF), UnpackZ(pack >> 20));
}

vec3 GetColor(uint id){
    return vec3(localSharedR[id], localSharedG[id], localSharedB[id])
}

void GetBBox(uint fillIdx, uint holeIdx, out vec3 bBoxMin, out vec3 bBoxMax){
    bBoxMin = bBoxMax = GetColor(fillIdx);
    vec3 a = GetColor(fillIdx - kLdsPitch - 1);
    vec3 b = GetColor(fillIdx - kLdsPitch + 1);
    bBoxMin = min(bBoxMin, min(a, b));
    bBoxMax = max(bBoxMax, max(a, b));
    a = GetColor(fillIdx + kLdsPitch - 1);
    b = GetColor(fillIdx + kLdsPitch + 1);
    bBoxMin = min(bBoxMin, min(a, b));
    bBoxMax = max(bBoxMax, max(a, b));
    a = GetColor(holeIdx);
    // b = GetColor(holeIdx - kLdsPitch - 1);
    b = GetColor(holeIdx - fillIdx + holeIdx);
    bBoxMin = min(bBoxMin, min(a, b));
    bBoxMax = max(bBoxMax, max(a, b));
}

void ApplyTemporalBlend(uint dstID, uint srcID, vec3 bBoxMin, vec3 bBoxMax){

}

void main(){
    const uint ldsHalfPitch = kLdsPitch / 2;
    uvec3 groupID = gl_WorkGroupID;
    uint groupIndex = gl_WorkGroupID.x + gl_WorkGroupID.y * gl_NumWorkGroups.x;

    for (uint i = groupIndex; i < 45; i += 64)
    {
        uint x = (i % ldsHalfPitch) * 2;
        uint y = (i / ldsHalfPitch) * 2;
        uint topLeftIdx = x + y * kLdsPitch;
        uvec2 topLeftST = groupID.xy * uvec2(8, 8) - 1 + uvec2(x / 2u, y);
        vec2 UV = extent.zw * (topLeftST * vec2(2, 1) + vec2(2, 1));

        vec4 depths = textureGather(depthMap, UV, 0);
        localSharedDepth[topLeftIdx + 0] = depths.w;
        localSharedDepth[topLeftIdx + 1] = depths.z;
        localSharedDepth[topLeftIdx + kLdsPitch] = depths.x;
        localSharedDepth[topLeftIdx + 1 + kLdsPitch] = depths.y;

        vec4 r4 = textureGather(colorMap, UV, 0);
        vec4 g4 = textureGather(colorMap, UV, 1);
        vec4 b4 = textureGather(colorMap, UV, 2);

        localSharedR[topLeftIdx] = r4.w; localSharedR[topLeftIdx + 1] = r4.z; localSharedR[topLeftIdx + kLdsPitch] = r4.x; localSharedR[topLeftIdx + 1 + kLdsPitch] = r4.y;
        localSharedG[topLeftIdx] = g4.w; localSharedG[topLeftIdx + 1] = g4.z; localSharedG[topLeftIdx + kLdsPitch] = g4.x; localSharedG[topLeftIdx + 1 + kLdsPitch] = g4.y;
        localSharedB[topLeftIdx] = b4.w; localSharedB[topLeftIdx + 1] = b4.z; localSharedB[topLeftIdx + kLdsPitch] = b4.x; localSharedB[topLeftIdx + 1 + kLdsPitch] = b4.y;
    }

    memoryBarrierShared();
    barrier();

    uint idx0 = gl_LocalInvocationID.x * 2u + (gl_LocalInvocationID.y + 1u) * kLdsPitch + 1u;
    uint idx1 = idx0 + 1;

    vec3 bBoxMin, bBoxMax;
    GetBBox(idx0, idx1, bBoxMin, bBoxMax);

    uvec2 st0 = gl_LocalInvocationID.xy * uvec2(2u, 1u);
    ApplyTemporalBlend(st0, idx0, bBoxMin, bBoxMax);

    uvec2 st1 = st0 + uvec2(1u, 0u);
    ApplyTemporalBlend(st1, idx1, bBoxMin, bBoxMax);
}